<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/OBJLoader.js"></script>

  </head>
  <body>
    <!--     <iframe id="model-viewer" src="indexMW.html#sanitairesModop" width= "100%" height = "1000px"></iframe> -->
    
      <script>
      console.clear();

// Set up the scene
var scene = new THREE.Scene();
        
        // Create an AxesHelper
const axesHelper = new THREE.AxesHelper(5); // Specify the size of the axes helper
        axesHelper.position.set(0,1,0)

// Add the AxesHelper to the scene
scene.add(axesHelper);
// Set up the camera
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);
const targetPosition = new THREE.Vector3(5, 5, 0); // Target position in world coordinates.
camera.lookAt(targetPosition);


// Create a renderer
var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff); // Set the clear color to white
document.body.appendChild(renderer.domElement);

// Create the floor
        
      
        
var carreauGeo = new THREE.BoxGeometry(1,1,.1);
var carreauMat = new THREE.MeshPhongMaterial({color:"lightgray",roughness :.2,metallness:.7});
        for (i=0;i<18;i++){
          for(j=0;j<18;j++){
            var carreau= new THREE.Mesh(carreauGeo,carreauMat);
            
            scene.add(carreau);
            carreau.position.set(i*1.11-9.7,0,j*1.12-3.4);
            carreau.rotation.x = Math.PI/2
          }
        }
    

        
        var floorGeometry = new THREE.PlaneGeometry(20, 20);
var floorMaterial = new THREE.MeshStandardMaterial({ color: "gray" });
var floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.position.z=6
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// Create the walls
        
        var carreauGeo = new THREE.BoxGeometry(1,1,.1);
var carreauMat = new THREE.MeshPhongMaterial({color:"lightgray",roughness :.2,metallness:.7});
        for (i=0;i<18;i++){
          for(j=0;j<11;j++){
            var carreau= new THREE.Mesh(carreauGeo,carreauMat);
            
            scene.add(carreau);
            carreau.position.set(i*1.11-9.7,j*1.11+.5,-4);
            // carreau.rotation.x = Math.PI/2
          }
        }
        
//     couleur du frontWall
        
        var wallGeometry = new THREE.PlaneGeometry(20, 12);
var wallMaterial = new THREE.MeshStandardMaterial({ color: "gray" });
var frontWall = new THREE.Mesh(wallGeometry, wallMaterial);

//frontWall.rotation.y = -Math.PI/2;
       frontWall.position.x = -.2;
        frontWall.position.z = -4;
        frontWall.position .y = 6
        ;
scene.add(frontWall);
        
        
        //sideWall
        
                var carreauGeo = new THREE.BoxGeometry(1,1,.1);
var carreauMat = new THREE.MeshPhongMaterial({color:"lightgray",roughness :.2,metallness:.7});
        for (i=0;i<19;i++){
          for(j=0;j<11;j++){
            var carreau= new THREE.Mesh(carreauGeo,carreauMat);
            
            scene.add(carreau);
            carreau.position.set(10,j*1.11+.5,i*1.11-5+.6);
             carreau.rotation.y = Math.PI/2
          }
        }
        
var sidewallGeometry = new THREE.PlaneGeometry(20, 12);
var wallMaterial = new THREE.MeshStandardMaterial({ color: "gray" });
var sideWall = new THREE.Mesh(sidewallGeometry, wallMaterial);

sideWall.rotation.y = -Math.PI/2;
        sideWall.position.x = 10;
        sideWall.position.z = 6;
        sideWall.position .y = 6
        ;
scene.add(sideWall);
        
// Create the Inox (stainless steel) material
var inoxMaterial = new THREE.MeshStandardMaterial({
 color: "white", // Set the base color to white
  metalness: .6, // Increase the metalness to make it look like stainless steel
  roughness: 0.4, // Adjust the roughness for the desired level of reflection
 
});
      
      // Load the texture map
var textureLoader = new THREE.TextureLoader();
var inoxTexture = textureLoader.load('https://cdn.glitch.global/48b8a110-6b48-49f9-b4a6-f75c5907dfc8/inox.jpeg?v=1689839970104');

// Assign the texture map to the material
inoxMaterial.map = inoxTexture;

// // import fridge
      
const loader1 = new THREE.OBJLoader();
const objFilePath = 'https://cdn.glitch.global/48b8a110-6b48-49f9-b4a6-f75c5907dfc8/11646_Refrigerator_v1_l3.obj?v=1689929673489';
loader1.load(
  objFilePath,
  (object) => {
    object.traverse((child) => {
      if (child instanceof THREE.Mesh) {
       
        child.material = inoxMaterial;
      }
    });
    object.scale.set(.05, 0.05, 0.05);
    object.position.set(7.8, 0, 11);
    object.rotateX(THREE.Math.degToRad(-90));
     object.rotateZ(THREE.Math.degToRad(-90));

    scene.add(object);
  }
);

//import appliances
const gltfLoader = new THREE.GLTFLoader();
gltfLoader.load('https://cdn.glitch.global/48b8a110-6b48-49f9-b4a6-f75c5907dfc8/FabConvert.com_commercialkitchenpack1.glb?v=1689947238261', (gltf) => {
  // Set up the materials in the model
  gltf.scene.traverse((object) => {
   object.traverse((child) => {
    if (child.isMesh) {
   //   console.log('material',child.material.name)
     //child.material.color.set("white");
     child.material = inoxMaterial;
     //child.material.transparent = true;
     //child.material.opacity =  1;

    }
  });
 
gltf.scene.scale.set(4.8,5,5);
   gltf.scene.position.set(0,0,-2);
  
  });


  // Add the model to the scene
  scene.add(gltf.scene);
  });
  
   // import sink
         
const gltfLoader1 = new THREE.GLTFLoader();
gltfLoader1.load('https://cdn.glitch.global/48b8a110-6b48-49f9-b4a6-f75c5907dfc8/sink_v001_LOD0.gltf?v=1690182180761', (gltf) => {
  // Set up the materials in the model
  gltf.scene.traverse((object) => {
   object.traverse((child) => {
    if (child.isMesh) {
   //   console.log('material',child.material.name)
     child.material.color.set("white");
     child.material = inoxMaterial;
     child.material.transparent = true;
    // child.material.opacity = 1;
    }     
  });
  });
gltf.scene.rotateY(THREE.Math.degToRad(-90))
  gltf.scene.scale.set(.05,.05,.05);
  gltf.scene.position.set (7.8,0,4);
  // Add the model to the scene
  scene.add(gltf.scene);
  });
  
//Add lights to the scene
var ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
        
        // Add multiple point lights on the ceiling for a plafond-like effect
var numLights = 3;
var radius = 5;
var height = 12;
for (var i = 0; i < numLights; i++) {
    var angle = (i / numLights) * Math.PI * 2;
    var light = new THREE.PointLight("#e3c8a1", .8, 15);
    light.position.set(radius * Math.cos(angle), height, radius * Math.sin(angle)+5);
    scene.add(light);
  var help= new THREE.PointLightHelper(light);
  scene.add(help)
}

// var directionalLight = new THREE.DirectionalLight(0xffffff, .3);
// directionalLight.position.set(0,15, 15);
// scene.add(directionalLight);
        
//         var helperD = new THREE.DirectionalLightHelper(directionalLight);
//         scene.add(helperD);
//  var pointLight = new THREE.PointLight(0xffffff, .3);
//  pointLight.position.set(2, 3, 5);
// scene.add(pointLight);
        
var spotLight1 = new THREE.SpotLight("#eda558", 0.3);
spotLight1.position.set(-2, 10, -1);


// Adjust the frustum of the spot light
spotLight1.angle = Math.PI / 6; // Reduce the angle to 30 degrees
spotLight1.penumbra = .5;
        scene.add(spotLight1);

var targetObject = new THREE.Object3D();
targetObject.position.set(0, -10, -3);
scene.add(targetObject);

//Set the target of the spotlight
spotLight1.target = targetObject;

var helper1 = new THREE.SpotLightHelper(spotLight1);
//scene.add(helper1);
        
        // duplicate spotLight 
      const spot2 = spotLight1.clone();
      const helper2 = new THREE.SpotLightHelper(spot2);
  scene.add(spot2) ;
        spot2.position.set(4, 10, -1);
        
 // scene.add(helper2);

        
        
      
      // Create the controls
var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 1, 0); // Set the target point around which the camera orbits

// Render the scene
function animate() {
  requestAnimationFrame(animate);
  
   // Update the controls
  controls.update();
  
  renderer.render(scene, camera);
}
        
          // add raycaster et touchstart ,click  
    const raycaster = new THREE.Raycaster();
    
     if(isMobile())  {
   
   console.log("ismobile"+isMobile());
   console.log(navigator.userAgent);
window.addEventListener('touchstart', onTouchStart, false);
//window.addEventListener('touchmove', onTouchMove, false);
   
 } else{
    console.log("isLapTop");
window.addEventListener('mousemove', onMouseMove, false); // Add a mousemove event listener to the window object
window.addEventListener('click', onClick, false); // Add a click event listener to the window object
 } 
    
function isMobile(){
// Check the user agent string to see if it contains "Mobile"
  return /Mobi/i.test(navigator.userAgent);  
}
    
    
    const mouse = new THREE.Vector2();

  function onMouseMove(event) {
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
}
    
    function onTouchMove(event) {
     // event.preventDefault();
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
}
    
  function onClick(event) {
    
  const intersects = raycaster.intersectObjects(scene.children,true);
    // Get the intersected mesh
    
     if (intersects.length > 0) {
    const mesh = intersects[0].object;
    
  
console.log(mesh.name);
 var name = mesh.name
              //     //calculate the position of the spriteNumero
              //  const intersection = intersects[0].point;
              // const offsetDistance = -.3; // adjust this as needed
              // const offset = raycaster.ray.direction.clone().multiplyScalar(offsetDistance);
              // console.log([intersection.x + offset.x, intersection.y + offset.y, intersection.z + offset.z]);  
     
var index = name.substr(name.length - 1);
    console.log(index);
    
    //  for (var j = 0; j < videoTextures.length; j++) {
    //     if (j == index-1){
    // videoSprites[j].visible =true;
    // planes[j].visible = true;    
    // videos[j].play();
    // textSprites[j].visible = true;
          
          // ajuster la position de la camera
          
//           const meshPosition = mesh.position.clone();
//           const cameraOffsetX = -5;
//           const cameraOffsetZ =10;
//           const cameraPosition = meshPosition.clone().add(new THREE.Vector3(cameraOffsetX, 0, cameraOffsetZ));
  
//   // // Move the camera to the new position
//   // camera.position.copy(cameraPosition);
//            // Move the camera smoothly to the new position
//   gsap.to(camera.position, {
//     x: cameraPosition.x,
//     y: cameraPosition.y+2,
//     z: cameraPosition.z,
//     duration: 2, // You can adjust the duration to control the speed of the camera movement
//     ease: "power2.out" // You can choose a different easing function for a different effect
//   });
  
//   // Update the camera's lookAt to center on the clicked sprite
//   camera.lookAt(meshPosition);
  
//   // You may also want to adjust the camera's up vector to ensure it's correctly oriented
//   camera.up.set(0, 2, 0);

  
        // }    else {
//        videoSprites[j].visible = false; // hide other video sprites
//         planes[j].visible = false; 
//         videos[j].pause(); // pause other videos
//         textSprites[j].visible = false;
      
      // }
  }
  }
  
 // }     
    
    
      function onTouchStart(event) {
        
         event.preventDefault();
         const touch = event.touches[ 0 ];
  const x = ( touch.clientX / window.innerWidth ) * 2 - 1;
  const y = - ( touch.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera( new THREE.Vector2( x, y ), camera );
        
  const intersects = raycaster.intersectObjects(scene.children,true);
           
  if (intersects.length > 0) {
      
  //  console.log('Clicked object:', intersects[0].object.material);
    // Get the intersected mesh
    const mesh = intersects[0].object;
    
  
console.log(mesh.name);
 var name = mesh.name
              //     //calculate the position of the spriteNumero
              //  const intersection = intersects[0].point;
              // const offsetDistance = -.3; // adjust this as needed
              // const offset = raycaster.ray.direction.clone().multiplyScalar(offsetDistance);
              // console.log([intersection.x + offset.x, intersection.y + offset.y, intersection.z + offset.z]);  
     
var index = name.substr(name.length - 1);
    console.log(index);
    
//      for (var j = 0; j < videoSprites.length; j++) {
//         if (j == index-1){
//     videoSprites[j].visible =true;
//     videos[j].play();[j]
//      planes[j].visible = true;
//     textSprites[j].visible = true;
                   
//           // ajuster la position de la camera
          
//           const meshPosition = mesh.position.clone();
//           const cameraOffsetX = -5;
//           const cameraOffsetZ =10;
//           const cameraPosition = meshPosition.clone().add(new THREE.Vector3(cameraOffsetX, 0, cameraOffsetZ));
  
//   // // Move the camera to the new position
//   // camera.position.copy(cameraPosition);
//            // Move the camera smoothly to the new position
//   gsap.to(camera.position, {
//     x: cameraPosition.x,
//     y: cameraPosition.y,
//     z: cameraPosition.z,
//     duration: 2, // You can adjust the duration to control the speed of the camera movement
//     ease: "power2.out" // You can choose a different easing function for a different effect
//   });
  
//   // Update the camera's lookAt to center on the clicked sprite
//   camera.lookAt(meshPosition);
  
//   // You may also want to adjust the camera's up vector to ensure it's correctly oriented
//   camera.up.set(0, 1, 0);
     
// }  else {
//       // videoSprites[j].visible = false; // hide other video sprites
//       // videos[j].pause(); // pause other videos
//       // planes[j].visible = false
//       }
//     }
   }
}
     

    
    

animate();

      
        </script>
    <!--  <script src = "buildScene.js"></script> -->
  </body>
</html>
