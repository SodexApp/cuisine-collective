<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body>
    <!--     <iframe id="model-viewer" src="indexMW.html#sanitairesModop" width= "100%" height = "1000px"></iframe> -->
    <script>
      const scene = new THREE.Scene();
      scene.background = null; //new THREE.Color(0, 0, 0, 0);
      

// Create an ambient light
const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); // Specify color and intensity

// Add the ambient light to the scene
//scene.add(ambientLight);
      // Create a directional light
const directionalLight = new THREE.DirectionalLight(0xffffff, .2); // Set the color and intensity of the light
directionalLight.position.set(0, .5, -5); // Set the position of the light (from the top)

// Add the directional light to the scene
scene.add(directionalLight);


// Create an AxesHelper
const axesHelper = new THREE.AxesHelper(5); // Specify the size of the axes helper

// Add the AxesHelper to the scene
scene.add(axesHelper);


      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create the camera and its target
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-5, 10, 7);
      const target = new THREE.Vector3(0, -3, -10);

      // import object cuisine
      
     
      const gltfLoader = new THREE.GLTFLoader();
      gltfLoader.load(
        "https://cdn.glitch.global/48b8a110-6b48-49f9-b4a6-f75c5907dfc8/cuisineIndustrielle.gltf?v=1666344790074",
        (gltf) => {
          // Set up the materials in the model
          gltf.scene.traverse((object) => {
           object.traverse((child) => {
              if (object.isMesh) {
                
//                 // Create an environment map for reflections (e.g., CubeTextureLoader, HDRCubeTextureLoader)
// const reflectionCube = new THREE.CubeTextureLoader()
//   .setPath('path/to/environmentMap/')
//   .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);
// reflectionCube.mapping = THREE.CubeReflectionMapping;
              // Set up the material for metallic effect
const metallic = new THREE.MeshStandardMaterial({
    color: "cloud",//0xffffff,         // Color of the material
  emissive: "silver",      // Emissive color (black in this case)
  emissiveIntensity:.7,    // Emissive intensity (adjust as needed)
  metalness: .5,            // Metallic property
  roughness: 0.7,          // Roughness property
  transparent: true,       // Enable transparency
  opacity: 1,            // Opacity level (adjust as needed)
 
});
                child.material = metallic;
              }
            });
            gltf.scene.children[0].scale.set(1, 1, 1);
            gltf.scene.children[0].position.set(5, 0, 0);
            gltf.scene.children[0].rotateY(THREE.Math.degToRad(180));
             // gltf.scene.children[0].rotateX(THREE.Math.degToRad(-100));
          });

          console.log(gltf.scene.children[0]);
//           
          
//         const sol = ["_526","_526_1"];

//           paintMesh(gltf,sol,"blue",.1)
          const mur =["_128"]
          removeMesh(gltf,mur);

         const plafond= ["_87","_87_1","_89","_89_1","_95","_95_1","_104","_105","_103","_103_1","_90_2","_93","_93_1","_85","_85_1","_102_1","_86_1","_84_1","_83","_83_1","_92_1","_94_1","_88_1","_101","_101_1","_99","_99_1","_534","_534_1","_100_1","_102_2","_128_1","_96_1","_106_1","_106_2","_105_1","_90_1","_104_1","_98_1","_97","_97_1","_91_1","_91"];
           
          removeMesh(gltf,plafond);
          
          const porte = ["_126_2"];
          paintMesh(gltf,porte,0xFFBF00,1);
             
          const meuble = ["_271","_270","_285_1","_279","_276_1","_294_1","_292_1","_54_1","_273","_273_1","_272","_272_1","_286","_286_1","_283_1","_287","_287_1","_277","_277_1","_281","_281_1","_278","_278_1","_280","_290","_290_1","_295","_295_1","_282","_282_1","_291","_291_1","_296","_296_1","_270_1","_271_1","_274","_274_1","_294","_292","_275_1","_288","_288_1","_289","_276","_283","_275","_279_1","_284","_284_1","_293","_293_1","_285","_280_1","_289_1","_54"];
          removeMesh(gltf,meuble);

         // remove Man
          const man = gltf.scene.children[0].getObjectByName("mesh_0");
          man.material.tranparent = true;
          man.material.opacity = 0;

          for (let i = 1; i < 18; i++) {
            const man = gltf.scene.children[0].getObjectByName("mesh_0_" + i);
            man.material.tranparent = true;
            man.material.opacity = 0;
          }

          scene.add(gltf.scene.children[0]);

          // create control
          controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.update();

          // // recuperation du controle
          // function animateOrbitControls() {
          //   controls.update();
          //   controls.target.set(0, 0, 0);
          //   //camera.position.z += 0.001;
          //   renderer.render(scene, camera);
          //   requestAnimationFrame(animateOrbitControls);
          // }

          // Set up the lighting in the scene
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
          //ambientLight.position.set(0, 2, 0);
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(0, -5, 2);

          scene.add(directionalLight);


          // Render the scene
          renderer.render(scene, camera);
        }
      );






      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // add raycaster et touchstart ,click
      const raycaster = new THREE.Raycaster();

      if (isMobile()) {
        console.log("ismobile" + isMobile());
        console.log(navigator.userAgent);
        window.addEventListener("touchstart", onTouchStart, false);
        //window.addEventListener('touchmove', onTouchMove, false);
      } else {
        console.log("isLapTop");
        window.addEventListener("mousemove", onMouseMove, false); // Add a mousemove event listener to the window object
        window.addEventListener("click", onClick, false); // Add a click event listener to the window object
      }

      function isMobile() {
        // Check the user agent string to see if it contains "Mobile"
        return /Mobi/i.test(navigator.userAgent);
      }

      const mouse = new THREE.Vector2();

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
      }

      function onTouchMove(event) {
        // event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
      }

      function onClick(event) {
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
          //  console.log('Clicked object:', intersects[0].object.material);
          // Get the intersected mesh
          const mesh = intersects[0].object;

          console.log(mesh);
          console.log(mesh.name);
       
          mesh.material.color.set("red");
          var name = mesh.name;
          //calculate the position of the spriteNumero
          const intersection = intersects[0].point;
          
         console.log(intersection);
          const offsetDistance = -0.3; // adjust this as needed
          const offset = raycaster.ray.direction
            .clone()
            .multiplyScalar(offsetDistance);
       
     
          controls.target.copy(intersection);

          var index = name.substr(name.length - 1);
          console.log(index);

          // for (var j = 0; j < videoTextures.length; j++) {
          //   if (j == index - 1) {
          //     videoSprites[j].visible = true;
          //     planes[j].visible = true;
          //     videos[j].play();
          //     textSprites[j].visible = true;
          //   } else {
          //     videoSprites[j].visible = false; // hide other video sprites
          //     planes[j].visible = false;
          //     videos[j].pause(); // pause other videos
          //     textSprites[j].visible = false;
          //   }
          // }
        }
      }

      function onTouchStart(event) {
        // event.preventDefault();
        const touch = event.touches[0];
        const x = (touch.clientX / window.innerWidth) * 2 - 1;
        const y = -(touch.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(new THREE.Vector2(x, y), camera);

        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
          //  console.log('Clicked object:', intersects[0].object.material);
          // Get the intersected mesh
          const mesh = intersects[0].object;

          console.log(mesh.name);
          var name = mesh.name;
          //     //calculate the position of the spriteNumero
          //  const intersection = intersects[0].point;
          // const offsetDistance = -.3; // adjust this as needed
          // const offset = raycaster.ray.direction.clone().multiplyScalar(offsetDistance);
          // console.log([intersection.x + offset.x, intersection.y + offset.y, intersection.z + offset.z]);

          var index = name.substr(name.length - 1);
          console.log(index);

          for (var j = 0; j < videoSprites.length; j++) {
            if (j == index - 1) {
              videoSprites[j].visible = true;
              videos[j].play();
              [j];
              planes[j].visible = true;
            } else {
              videoSprites[j].visible = false; // hide other video sprites
              videos[j].pause(); // pause other videos
              planes[j].visible = false;
            }
          }
        }
      }

      // window.addEventListener('touchstart', onClick, false);
      // window.addEventListener('mousemove', onMouseMove, false);
      // window.addEventListener('click', onClick, false);

      animate();
      
      function removeMesh(gltf,meshArray){
         for(i=0;i<meshArray.length;i++){
           const meshToRemove = gltf.scene.children[0].getObjectByName("mesh"+meshArray[i]);
       if (meshToRemove.parent) {
           meshToRemove.parent.remove(meshToRemove);
          } else {
            scene.remove(meshToRemove);
          } 
      }
      }
      
      function paintMesh(gltf,meshArray,color,opacity){
        for(i=0;i<meshArray.length;i++){
          const meshToPaint = gltf.scene.children[0].getObjectByName("mesh"+meshArray[i]);
          console.log(meshToPaint);
          meshToPaint.material.emissive.set(color);
          meshToPaint.material.transparent = true;
          meshToPaint.material.opacity = opacity;
        }
      }
    </script>
     <script src = "buildScene.js"></script>
  </body>
</html>
